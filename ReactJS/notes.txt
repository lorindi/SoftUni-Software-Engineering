Промисът в програмирането е концепция, която се използва за управление на асинхронни операции. 
Той представлява обект, който представя резултата от асинхронна операция, като например извличане на данни от база данни, 
заявка към уеб сървър или други подобни задачи, които отнемат време за изпълнение.

Основната идея зад промисите е да се улесни управлението на асинхронни операции и да се предостави начин за обработка на резултата от тези операции, 
когато те приключат - било те успешни или с грешка.

Промисите имат два основни състояния:

Pending (Изчакващ): Началното състояние на промиса, когато асинхронната операция все още не е завършила.

Fulfilled (Изпълнен): Състояние, в което асинхронната операция е успешно завършила и е върнала резултат.

Rejected (Отхвърлен): Състояние, в което асинхронната операция е завършила с грешка.

Промисите позволяват на програмистите да управляват последователни асинхронни операции по по-лесен начин, 
като използват методи като .then() и .catch(), които се извикват след успешното завършване или грешката на промиса съответно.

Ето пример как се създава и използва промис в JavaScript:

javascript
Copy code
// Създаване на промис
let promise = new Promise((resolve, reject) => {
    // Асинхронна операция (в този случай setTimeout)
    setTimeout(() => {
        // Проверка за условие и извикване на resolve или reject
        let success = true;
        if (success) {
            resolve("Успешно завършена операция");
        } else {
            reject("Грешка при операцията");
        }
    }, 2000);
});

// Използване на промиса
promise.then((result) => {
    console.log("Промисът е изпълнен:", result);
}).catch((error) => {
    console.error("Промисът е отхвърлен:", error);
});

Това е базов пример, който демонстрира създаването и използването на промис в JavaScript.
 В реални приложения промисите се използват за управление на множество асинхронни операции, които включват заявки към уеб сървъри, работа с файлове, бази данни и други.



Асинхронната операция в програмирането е вид операция, която не блокира изпълнението на кода, докато изчаква завършването на операцията. 
Вместо това, програмата продължава да изпълнява други инструкции, докато асинхронната операция се изпълнява отделно и възможно е да се завърши в бъдещ момент.

Такива операции са често срещани във входно-изходните операции като заявки към уеб сървъри, четене или записване на файлове, изпращане на съобщения по мрежа и други. 
Те могат да отнемат време поради различни причини, като например латентността на мрежата, скоростта на достъп до диска и други фактори.

В езиците като JavaScript, асинхронните операции се изпълняват чрез механизми като промиси, колбек функции или async/await синтаксис. 
Това позволява на програмистите да управляват асинхронни операции по по-лесен начин, без да блокират изпълнението на програмата. 
За разлика от синхронните операции, където следващият ред от код се изпълнява само след като текущият завърши, 
при асинхронните операции следващият ред може да се изпълни преди текущият да завърши.



В React промисът (Promise) се използва за управление на асинхронни операции и рендиране на компоненти, които зависят от резултата на тези операции. 
По същество, това е същият JavaScript промис, но често се използва в контекста на компонентния животен цикъл и асинхронни операции в React приложенията.

Промисите в React се използват за изпращане на асинхронни заявки към сървъри, извличане на данни от бази данни, работа с файлове и други асинхронни операции, 
които могат да бъдат необходими в приложението.
 Обикновено се използват за зареждане на данни преди рендирането на компоненти или за обработка на събития след тяхното рендиране.

Ето пример как може да се използва промис в React за извличане на данни от уеб сървър:

javascript

import React, { useState, useEffect } from 'react';

function MyComponent() {
  const [data, setData] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch('https://api.example.com/data');
        const jsonData = await response.json();
        setData(jsonData);
      } catch (error) {
        console.error('Грешка при извличане на данни:', error);
      }
    };

    fetchData();
  }, []);

  return (
    <div>
      {data ? (
        <ul>
          {data.map(item => (
            <li key={item.id}>{item.name}</li>
          ))}
        </ul>
      ) : (
        <p>Зареждане на данни...</p>
      )}
    </div>
  );
}

export default MyComponent;
Save to grepper
В този пример useEffect се използва за зареждане на данни след като компонентът е монтиран за първи път. 
Вътре в функцията fetchData се използва промис за извличане на данни от уеб сървъра. 
Когато данните бъдат получени успешно, те се сетват в състоянието на компонента с setData. 
Ако възникне грешка при извличане на данните, се хваща с catch, и се изписва грешката в конзолата. 
В рендър функцията се показва списък с данните или съобщение за зареждане, в зависимост от това дали data е null или не.



Рендерирането в програмирането, особено в контекста на уеб разработката и създаването на уеб приложения, 
се отнася до процеса на създаване на визуалното представяне на елементите на потребителския интерфейс (UI) на основата на данните и логиката,
 която се изпълнява в приложението.

В контекста на React (и други библиотеки/рамки за уеб разработка) рендерирането се отнася до процеса, 
при който компонентите се преобразуват от JavaScript код в действителни елементи на потребителския интерфейс, 
които могат да се визуализират в браузъра.

Процесът на рендериране в React обикновено е декларативен. 
Това означава, че програмистите декларират какво трябва да бъде рендерирано, а не изрично посочват как точно да бъде извършено рендерирането.

Рендерирането в React може да бъде инстанцирано от различни фактори, като например:

Промяна на състоянието (state): Когато състоянието на компонентите се промени, React изчислява отново какво трябва да се рендерира и актуализира UI,
 за да отрази новото състояние.

Пропси (props): Когато родителският компонент промени пропсите (данните), които предава на децата си, 
React изчислява отново какво трябва да се рендерира в детските компоненти и актуализира техния UI.

Извънредни събития (events): Например, когато потребителят извърши действие като кликне върху бутон, 
React може да се нуждае да актуализира UI в резултат на това действие.

Монтаж и демонтаж на компоненти: Когато компонент се добави или премахне от DOM (Document Object Model), 
React извършва съответните действия за рендериране или премахване на елементите от UI.

Рендерирането в React е ефективен и бърз процес, който поддържа виртуален DOM (Virtual DOM),
 който се използва за оптимизация на обновленията на UI и намаляване на излишните прерисувания.


В контекста на уеб разработката и по-конкретно във фронтенд рамките и библиотеки като React, 
"стейт" (state) обикновено се отнася до данните, които управляват поведението и визуализацията на компонентите. 
Той представлява информацията, която може да се променя по време на живота на компонента и може да влияе върху начина, по който той се рендерира.

В React, стейтът е обект, който се съхранява вътре в компонента и може да се актуализира с помощта на функции като setState(). 
Когато стейтът на компонента се промени, React автоматично преизчислява какво трябва да се рендерира и актуализира съответно UI.

Важно е да се отбележи, че стейтът в React е локален за даден компонент, което означава, 
че той се управлява само в рамките на този компонент и не се споделя с други компоненти,
 освен ако не бъде явно предаден като пропс (props) на деца компоненти.

Пример за използване на стейт в компонент в React:

javascript
Copy code
import React, { useState } from 'react';

function Counter() {
  // Дефиниране на стейт за брояча и функция за актуализация на стейта
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Бройч: {count}</p>
      {/* Бутон за увеличаване на брояча */}
      <button onClick={() => setCount(count + 1)}>Увеличи брояча</button>
    </div>
  );
}

export default Counter;

В този пример count е стейтът на компонента Counter, който показва текущата стойност на брояча. setCount е функция, 
която се използва за актуализиране на стейта. Когато потребителят кликне върху бутона, стойността на брояча се увеличава чрез setCount, 
което довежда до прерисуване на компонента с новата стойност.




Хук (hook) в React е функция, която позволява на функционални компоненти да използват състояние, животен цикъл и други функционалности, 
които преди това бяха достъпни само в класовите компоненти. 
Хуковете са добавени в React с версия 16.8 и предоставят по-удобен начин за работа със състояние и други функционалности във функционалните компоненти.

В React има няколко вградени хукове като useState, useEffect, useContext и други, които могат да бъдат използвани за различни цели. 
Освен вградените, потребителите могат също да създадат свои собствени хукове за повторно използване на логика между компоненти.

Ето някои от най-често използваните вградени хукове в React:

useState: Позволява на компонента да дефинира и използва състояние.

useEffect: Позволява на компонента да извършва странични ефекти като извличане на данни от API, 
подписване на събития и други, като реакция на промяна на състояние или други събития.

useContext: Позволява на компонента да достъпи стойности от контекст на родителски компонент.

useReducer: Предоставя алтернативен начин за управление на състояние чрез използване на reducer функции.

useRef: Позволява на компонента да запази мутираща се променлива между рендирането.

useMemo и useCallback: Позволяват на компонента да кешира стойности или колбек функции, които се мемоизират, 
за да се предотврати повторно изчисление при ререндиране на компонента.

Тези хукове позволяват на разработчиците да създават по-чист и преизползваем код, който е по-лесен за разбиране и поддръжка, 
като в същото време предлага всички възможности на класовите компоненти.


#Stenly
Какво е промис?
Promise е javascript object с методи и пропъртита. Инстанция на клас Promise
Какво прави този обект? 
Той показва евентуално пристигането на данни.
Защо ежентуално?
Защото моvе да се resolve-не с данните, може и да се reject-не с грешка.



Component Render?
- initial render
- parent render
- props changed
- state changed





