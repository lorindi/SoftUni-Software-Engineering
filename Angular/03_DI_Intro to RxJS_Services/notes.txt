https://medium.com/reverse-engineering-angular/angular-deep-dive-zone-js-how-does-it-monkey-patches-various-apis-9cc1c7fcc321
https://jsonplaceholder.typicode.com/users

*ng g s user

Сървисите нямат life cycle hook, освен един и той е ngOnDestroy!

Solid Principles (Принципи на софтуерното проектиране):
Single Responsibility Principle (Принцип на единствената отговорност): Всяка клас или модул трябва да има само една причина за промяна. 
Това означава, че трябва да се стремим да дефинираме компоненти, които се занимават само с една конкретна задача.
Open/Closed Principle (Принцип на отворено/затворено): Класовете и модулите трябва да бъдат отворени за разширяване, но затворени за промяна. 
Това се постига чрез използването на абстракции и полиморфизъм, вместо промяна на съществуващия код.
Liskov Substitution Principle (Принцип на подстановката на Лисков): Обекти от суперкласа трябва да могат да бъдат заместени с обекти от неговите 
подкласове без да се нарушава коректността на програмата.
Interface Segregation Principle (Принцип на сегрегацията на интерфейсите): Клиентите не бива да бъдат принуждавани да зависят от интерфейси, които не използват. 
Това означава, че трябва да разделяме големи интерфейси на по-малки и по-специфични такива.
Dependency Inversion Principle (Принцип на инверсията на зависимостите): Високо ниво модули не трябва да зависят от ниско ниво модули. И двете трябва да зависят от абстракции. 
Това означава, че трябва да създадем абстракции, които да свързват различните компоненти на приложението.

RxJS:
RxJS е библиотека за реактивно програмиране, която се използва широко в Angular. 
Тя позволява лесна работа с асинхронни данни и събития чрез използване на потоци (streams) и наблюдатели (observers).
Основните концепции в RxJS са потоци (streams), оператори (operators) и наблюдатели (observers). Потоците са последователност от стойности, 
които могат да бъдат манипулирани чрез различни оператори за филтриране, трансформация и комбиниране. Наблюдателите са обекти, 
които наблюдават потоците и реагират на промените в тях.
RxJS позволява лесно управление на асинхронни операции като HTTP заявки, събития от потребителски интерфейс и други.

Services (Сервизи):
В Angular, сервизите са класове, които се използват за обработка на логика, която не е пряко свързана с компонентите на приложението.
Сервизите се използват за споделяне на данни, обща логика и функционалност между различни компоненти на Angular приложението.
Те могат да бъдат инжектирани в други компоненти, услуги или директиви и да се използват в тях.
Подходящо е сервизите да се използват за взаимодействие с външни източници като HTTP сървъри, локално съхранение на данни и др.



Change Detection Strategy (Стратегия за откриване на промени):
В Angular, стратегията за откриване на промени определя как Angular реагира на промени във входни данни (input) или събития, които могат да повлияят на визуализацията на компонентите.
Angular предлага две основни стратегии за откриване на промени: Default и OnPush.
Стандартната стратегия (Default) преминава през всички компоненти при всяка промяна в контекста или входните данни, което може да доведе до излишни изчисления и рендериране.
Стратегията OnPush активира откриването на промени само когато има промени във входни данни или се подаде нова референция на обекта в компонента. 
Това може да подобри производителността на приложението, като се намали броят на проверките за промени.

Observables и RxJS:
Основната концепция на RxJS са observables, които са представението на поток от данни, които могат да се предоставят асинхронно от източник.
RxJS предлага множество оператори, които позволяват манипулиране и трансформиране на observables, като например map, filter, merge, combineLatest и други.
Observables позволяват удобно управление на асинхронни операции, като HTTP заявки, събития от потребителски интерфейс и други.

HTTP Client:
HTTP Client е модул в Angular, който се използва за изпращане на HTTP заявки към сървъри.
Той предоставя интерфейс за изпращане на заявки към REST API и получаване на отговори.
HTTP Client може да се използва за изпълнение на различни HTTP методи като GET, POST, PUT, DELETE и други.
Angular HTTP Client връща observables, които могат да бъдат обработени с RxJS оператори за манипулиране на данни.



Синхронно изпълнение:
Синхронното изпълнение се характеризира с последователност на изпълнението на операциите. 
Това означава, че една операция се изпълнява след друга, и програмата продължава напред само след като текущата операция е завършена.
При синхронно изпълнение програмата често блокира изпълнението си, докато чака определена операция да завърши, като например четене на файл от диска или изпращане на HTTP заявка към сървър.

Асинхронно изпълнение:
В асинхронното изпълнение операциите не се изпълняват последователно. Вместо това, програмата продължава изпълнението си, докато асинхронните операции се изпълняват във фонов режим.
Това позволява на програмата да бъде по-ефективна и да не блокира изпълнението си, докато чака определена операция да завърши.
Примери за асинхронни операции включват изпращане на HTTP заявки, четене на файлове от диска, обработка на събития от потребителски интерфейс и други.



В Angular, Dependency Injection е вграден механизъм, който позволява лесно инжектиране на различни компоненти, услуги, директиви и други зависимости в други части на приложението. 
Това прави възможно постигането на по-голяма модуларност и преизползваемост на кода.

Пример за използване на Dependency Injection в Angular е инжектирането на сервизи в компоненти чрез конструктор или анотация, което позволява лесно използване на функционалността 
на тези сервизи във въпросния компонент. Така например, ако имате сервиз, който извършва HTTP заявки към сървъра, можете да го инжектирате в компонент, който използва тези данни, 
без да се налага да създавате нова инстанция на сервиза в самия компонент.

Dependency Injection помага на разработчиците да се съсредоточат върху бизнес логиката на приложението, вместо да се притесняват за създаването и управлението на обекти. 
Той също така прави кода по-лесен за тестване, тъй като позволява лесно подаване на мокове (mocks) или фалшифицирани обекти при изпълнението на модулни или интеграционни тестове.




В контекста на Angular, услугите (services) са класове, които се използват за обработка на логика, споделени данни или функционалности, 
които не са пряко свързани с компонентите на приложението. Те представляват важен компонент от архитектурата на Angular приложенията и
 са един от основните механизми за споделяне на функционалност между различни компоненти.

Ето някои основни характеристики на услугите в Angular:
Създаване на Услуги:
Услугите се създават като класове в Angular. Можете да генерирате нова услуга с Angular CLI командата ng generate service service-name.

Инжектиране на Услуги:
Услугите се инжектират (подават) в компоненти, други услуги или директиви, които ги използват. 
Това се прави чрез конструктора на компонентите или чрез декоратора @Injectable() за самите услуги.

Споделяне на Данни и Функционалности:
Услугите се използват за споделяне на общи данни и функционалности между различни части на приложението. 
Например, може да имате услуга, която управлява аутентикацията на потребителите, или услуга, която извършва HTTP заявки към сървър.

Логика и Функционалности:
В услугите може да се помещава бизнес логика, манипулации с данни, обработка на събития или други функционалности, които не са специфични за някой конкретен компонент.

Жизнен Цикъл:
Услугите имат свой собствен жизнен цикъл, който се управлява от Angular. Това означава, че те могат да бъдат създадени, инстанцирани и унищожени от Angular, когато е необходимо.

Тестване:
Услугите са лесни за тестване, тъй като може да се изолират и мокват (mock), което прави модулното и интеграционно тестване на компонентите, които ги използват, по-лесно.
Обикновено в Angular приложенията, услугите се използват за централизиране на логиката, обработката на данни и взаимодействието с външни източници като HTTP сървъри или локално съхранение. Те също така могат да бъдат използвани за споделяне на данни и функционалности между различни компоненти, без да се налага тези компоненти да имат пряко връзка помежду си.




Domain-Driven Design (DDD) е методология в софтуерното инженерство, която се фокусира върху създаването на софтуерни системи, които отразяват или моделират реални бизнес домейни. Целта на DDD е да се създаде софтуер, който е по-разбираем, лесен за поддържане и отразява точно бизнес правилата и процесите, които се реализират в него.

Основният принцип на DDD е фокусирането върху бизнес домейна и неговата логика, а не само върху техническите аспекти на системата. За целта, DDD въвежда няколко ключови концепции:

Бизнес модел:

Бизнес моделът е централният елемент на DDD. Той представлява формален модел на бизнес домейна, който съдържа ключовите същности, правила и процеси в системата.

Ограничения на контекста:
DDD разглежда бизнес домейна като множество на ограничени контексти, като всяка част от системата има ясно дефинирани граници и правила, които се прилагат в рамките на този контекст.
Същности и стойности:

В DDD, бизнес същностите се разглеждат като обекти с идентичност и жизнен цикъл, които отразяват реалните обекти или понятия в бизнес домейна. 
Същностите са обикновено постоянни и се проследяват чрез идентификатори.
Същностите се различават от стойностите, които са обекти без идентичност, чиито стойности се определят от техните атрибути.

Агрегати:
Агрегатите са групи от свързани същности, които се управляват като единица. Те имат корен (root), който служи като точка на достъп и координира операциите в рамките на агрегата.

Репозитории:
Репозиториите са механизми за достъп до данни, които позволяват операции със същности, без да се нарушават техните граници или правила.

Събития и домейн събития:
Събитията са ключов елемент в DDD, тъй като те се използват за записване на промени в системата и се използват за комуникация между различните части на системата.
Домейн събитията са събития, които отразяват важни състояния или промени в бизнес домейна и са централни за архитектурата на системата.
DDD е мощен инструмент за проектиране на софтуерни системи, които отразяват сложни бизнес домейни и процеси. 
Той съчетава бизнес анализ, моделиране на данни и софтуерна архитектура, за да създаде системи, които са лесни за разбиране, разработване и поддържане.





Синхронен код:
В синхронния код операциите се изпълняват последователно, една след друга, в реда, в който са дефинирани.
Всяка операция трябва да приключи, преди да започне следващата. Това означава, че програмата "блокира" всяко извикване на операция, докато не приключи изпълнението й.
Синхронният код е по-прости за разбиране и отстраняване на грешки, тъй като операциите се изпълняват в очаквания ред.
Пример за синхронен код в JavaScript:

console.log("Start");

function synchronousOperation() {
    console.log("Synchronous operation");
}

synchronousOperation();

console.log("End");

Асинхронен код:
В асинхронния код операциите не се изпълняват последователно. Вместо това, програмата продължава изпълнението си, докато асинхронните операции се изпълняват във фонов режим.
Това позволява на програмата да бъде по-ефективна и да не блокира изпълнението си, докато чака определена операция да приключи, като например извикване на сървър или зареждане на файл.
Асинхронният код е по-сложен за управление, тъй като изисква обработка на резултатите от асинхронните операции и гарантиране на правилния ред на изпълнение на операциите.
Пример за асинхронен код в JavaScript (използвайки Promise):

console.log("Start");

function asynchronousOperation() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log("Asynchronous operation");
            resolve();
        }, 1000);
    });
}

asynchronousOperation().then(() => {
    console.log("After asynchronous operation");
});

console.log("End");

В горния пример "End" се отпечатва преди "After asynchronous operation", тъй като асинхронната операция (setTimeout) се изпълнява след това,
 което дава възможност на програмата да продължи изпълнението си.




В Angular, промисите (Promises) се използват широко за обработка на асинхронни операции, като например изпращане на HTTP заявки към сървъра, 
зареждане на данни от база данни и други асинхронни операции. Промисите представляват обект, който представя определено състояние на асинхронната операция 
(например, "pending", "resolved", "rejected") и позволяват да се регистрират обработчици (handlers) за успешното завършване или грешките.

Angular предоставя вграден сервиз - HttpClient, който връща промиси за асинхронните HTTP заявки. Това означава, че при изпращане на HTTP заявка, ще получите обект,
 който представлява промис, и можете да използвате методите .then() и .catch() за обработка на резултата от заявката или грешките, 
 които могат да възникнат по време на изпълнението й.

Ето пример как се използва HttpClient в Angular с промиси:

import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css']
})
export class ExampleComponent implements OnInit {
  constructor(private http: HttpClient) { }

  ngOnInit(): void {
    this.http.get('https://api.example.com/data')
      .toPromise()
      .then(response => {
        console.log('Data received:', response);
        // Обработка на получените данни
      })
      .catch(error => {
        console.error('Error occurred:', error);
        // Обработка на грешката
      });
  }
}

В горния пример, http.get() методът връща промис, който се преобразува в промис чрез използването на метода .toPromise(). 
След това можем да използваме .then() за обработка на успешния резултат от заявката и .catch() за обработка на възможните грешки.

Въпреки това, с Angular 4+ се препоръчва използването на RxJS Observable вместо промиси за обработка на асинхронни операции, 
тъй като те предоставят по-гъвкави възможности за манипулиране на данни и управление на потоците.




Ако бихме сравнявали асинхронните операции, извършвани с промиси и с RxJS Observable, със синхронни операции, то можем да използваме аналогия със следните кодове:

// Синхронна аналогия с Promise
[1].map((x) => x * 2).map((x) => x * 10);

Този код използва .map() методите за преобразуване на един елемент масив в друг, като първо умножава числото по 2,
 а след това го умножава отново по 10. Тъй като .map() операциите са синхронни, те се изпълняват веднага и в реда, в който са дефинирани.

// Синхронна аналогия с Observable
[1, 2, 3, 4, 5].map((x) => x * 2).map((x) => x * 10);

Тук имаме същата операция, но вместо да обработваме само един елемент, обработваме целия масив. Това представлява синхронна операция, 
тъй като всички елементи в масива се обработват веднъж и в реда, в който са дефинирани.

В RxJS, .map() методите работят подобно на техните синхронни аналози, като преобразуват входните данни в нови данни, като не променят оригиналните данни.
 Те са част от операциите, които могат да се използват върху потоци от данни (Observables) за тяхното преобразуване, филтриране и трансформиране.




Observable в Angular е част от RxJS библиотеката и представлява последователност от стойности или събития, които могат да бъдат наблюдавани. 
Те се използват за управление на асинхронни операции и данни, като например HTTP заявки, обработка на събития от потребителския интерфейс и други асинхронни процеси.

Observable може да изпраща нула, една или множество стойности, а след това да завърши успешно или с грешка. Той има различни методи за манипулиране на потока от данни, 
като например map, filter, reduce и други, които могат да се използват за трансформация, филтриране и агрегиране на данните.

Ето пример как да се използва Observable в Angular:

import { Observable } from 'rxjs';

// Създаване на нов Observable
const myObservable = new Observable<number>((observer) => {
  setTimeout(() => {
    observer.next(1); // Изпращане на първа стойност
    observer.next(2); // Изпращане на втора стойност
    observer.next(3); // Изпращане на трета стойност
    observer.complete(); // Означава край на потока от данни
  }, 1000);
});

// Подписване на Observable и обработка на стойностите
myObservable.subscribe({
  next: (value) => console.log('Received value:', value),
  error: (error) => console.error('Error occurred:', error),
  complete: () => console.log('Observable completed')
});

В този пример създаваме нов Observable, който изпраща последователно стойностите 1, 2 и 3 след кратка забавяне от 1 секунда. 
След като изпрати всички стойности, извикваме метода complete() на observer, за да сигнализираме, че потокът от данни приключва успешно. 
После се абонираме (подписваме) за този Observable, като предоставяме обекти с функции за обработка на получените стойности, в случай на грешка или при завършване на потока.




Реактивното програмиране е програмиране, което се базира на използването на потоци от данни и известни операции, които се изпълняват върху тези данни. 
Целта на реактивното програмиране е да се създаде по-чист, по-елегантен и по-ефективен код за управление на асинхронни и потокови данни.

В основата на реактивното програмиране стои понятието за реактивни потоци (reactive streams) или реактивни обекти (reactive objects), които са абстракции, 
представящи потокове от данни или събития. Тези потоци могат да бъдат манипулирани и трансформирани чрез различни операции, като филтриране, мапиране, агрегиране и други.

В съвременното софтуерно инженерство реактивното програмиране е широко използвано във фронтенд и бекенд разработка. Във фронтенд разработката, 
библиотеки като RxJS (реактивна програмираща библиотека за JavaScript), Angular, React и Vue.js включват функционалности за работа с реактивни потоци и обекти. 
Тези библиотеки предоставят удобни методи и оператори за манипулиране на данни и събития във фронтенд приложенията.

В бекенд разработката, реактивното програмиране се използва за управление на асинхронни операции и потоци от данни в сървърни приложения.
 Библиотеки като Reactor, Akka Streams, RxJava и Project Reactor предлагат инструменти за създаване на реактивни приложения в Java и други езици за програмиране.

Основните принципи на реактивното програмиране включват:

Наблюдение (Observation): Създаване на наблюдаеми обекти, които изпращат съобщения при промяна на състоянието си.

Подписване (Subscription): Регистриране на обработчици, които да получават съобщения от наблюдаемите обекти.

Манипулиране (Manipulation): Изпълнение на операции върху потоците от данни, като филтриране, мапиране, агрегиране и други.

Композиране (Composition): Съчетаване на различни операции и потоци за създаване на по-сложни потоци и операции.

Реактивното програмиране предоставя мощен и елегантен начин за управление на асинхронни и поточни данни в съвременните софтуерни приложения. 
То позволява създаването на по-елегантен и поддържаем код, който е по-лесен за разбиране и разширяване.